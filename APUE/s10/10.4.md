# 中断的系统调用
***

&emsp;&emsp;
早期 Unix 特征是：进程在执行一个低速的系统调用时，如果捕捉到了一个信号会返回错误，errno 等于 EINTR。
理由是一旦信号发生，意味系统发生某些事情，那么是唤醒阻塞的系统调用好机会。

&emsp;&emsp;
低速的系统调用，主要是针对那种很可能永久阻塞的系统调用，包括：

+ 读写和打开某些类型文件(管道，终端和网络设备等)
+ pause，wait 以及某些 ioctl 操作

&emsp;&emsp;
需要注意的是磁盘文件并不属于低速系统调用范围。

&emsp;&emsp;
对于存在中断的系统调用，必须显式处理中断情况：

    again:
        if((n = read(fd, buf, BUFFSIZE)) < 0) {
            if(errno == EINTR){
                goto again;
            }
            
            // handle error
        }
 
&emsp;&emsp;
为此 4.2BSD 引入了自动重启系统调用这个概念，不必处理被中断的系统调用。
因为自动重启也可能带来问题，所以 4.3BSD 允许进程基于每个信号来禁用自动重启功能。
Linux 系统默认也是自动重启，也支持基于信号来禁用自动重启。