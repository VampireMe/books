# SO_RCVBUF/SO_SNDBUF
***

&emsp;&emsp;
每个套接字都有一个发送缓冲区和接收缓冲区。
对于 TCP，接收缓冲区的大小在每次交互过程中都会传递，告诉发送端自己空闲缓冲区多少，这样发送端可以个根据接收端缓冲区大小来控制发送速度，不会出现发送端发送过快而接收端处理不过来，而不断地重传数据。
对于发送缓冲区来说如果kernel buffer没有空闲空间的话，那么write将会阻塞或者是返回EAGAIN的错误。对于UDP来说问题相对简单一些， 如果接收缓冲区过小的话，如果发送端发送过快就直接丢弃数据包，而发送端缓冲区大小是为了限制一次发送数据报大小，因为只要每次写操作，kernel buffer 立刻丢入网卡发送队列中。
UDP 相对来说概念简单一些，所以这里主要考虑 TCP。

&emsp;&emsp;
首先考虑设置这个选项时机，因为 TCP 的窗口规模选项是在建立连接时候使用 SYN 分节相互交换得到的，所以对于客户端必须在 connect 之前设置，而服务端必须在 listen 之前设置。
其次设置套接字缓冲区大小的时候必须考虑性能问题，通常来说管道的容量应该带宽 x 延迟， 在设置缓冲区大小时需要考虑管道的容量。
管道容量越大，那么设置的缓冲区大小也必须越大。
如果管道容量很大，缓冲区大小也很大，TCP 层必须允许交换这么大的窗口大小，这就是 TCP 的长胖管道特征 (long fat pipe)。

&emsp;&emsp;
@note: 设置了缓冲区大小，但取出来似乎不是设置的值。
并且通过 tcpdump 观察，似乎窗口并没有什么变化。
每次交换窗口大小和设置的没有任何关系。