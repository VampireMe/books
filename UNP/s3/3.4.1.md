# 滑动窗口
***

&emsp;&emsp;
如果 TCP 采用停止等待协议来进行数据传送，那么吞吐量是会存在问题的，完全可以采用类似于流水线的方式来提高吞吐量。
发送方可以在停止并等待确认之前发送多个连续分组，由于发送方不必等待每一个发送分组就停下来等待确认，可以加快数据的传输。
而这种传输方式就是滑动窗口传输方式。

&emsp;&emsp;
演示滑动窗口工作原理非常直观。
发送端只需要想象有一个连续的字节流，然后通过一个 window 来观察这个字节流。
每次发送的内容都是在 window 里的数据，一旦发送端接收到 window 最末端的字节 ACK，那么窗口就可以向前进行移动并且从内核 buffer 丢弃。
接收端也是同样的道理，首先有一个空 window，然后每接收到一些数据就向这个 window 里填充，一旦 window 最末端的被连续填充之后，窗口就可以向前移动并且返回 ACK，而被连续填充部分就可以报告给应用层，让应用层处理这个部分的数据。
这里需要注意的是，滑动窗口协议并不需要确认每一个字节，如果发送端接收的 ACK 为 x，就可以认为 x 以前的所有数据都已经被确认了。

&emsp;&emsp;
但是不要区分地看待这两个窗口。
事实上发送端是不会主动规定这个窗口大小的，这个窗口大小是接收端通知的。
接收端告诉发送端自己的窗口大小之后，这样发送端发送的数据只能够在这个窗口里，好处就是能够比较有效地处理快发送端到慢接收端这样的情况。
接收端一旦接收到数据，那么自己的窗口大小就变小了。
如果返回 ACK 时就会附带上自己的窗口大小，通知发送端可以少发送一些。
而一旦接收端将自己的数据推送给应用层之后，窗口大小变大那么也会通过捎带 ACK 或者是主动 ACK 通知发送端窗口大小发生变化，这个过程称为窗口更新。

&emsp;&emsp;
需要考虑一个问题是，接收端什么时候返回窗口更新的 ACK。捎带 ACK 是一个时机，另外一个时机就是主动发送 ACK 来通知发送端 (这样可以避免僵局)。
虽然 TCPv1 里没有提到这个过程，而是认为发送端应该主动进行使用坚持定时器进行窗口探测，但是从 TCPv1 (P212.Fig20-3，segemnt 9) 来看，接收端主动通过 ACK 来通知窗口更新，应用也是实现的一种方式。

&emsp;&emsp;
因为窗口大小是接收端来规定的，那么窗口大小是多少才合适呢？
因为这个影响到了 TCP 的性能。
其实和 CPU 流水线一样，如果数据能够充满通信介质，那么吞吐量是最高的。
计算通道容量为 capacity (bit) = bandwidth (b/s) \* round - trip - time (s)，这个被称为带宽时延乘积，也就是窗口大小最合适的值。
当不管有多少个报文段填充了这个管道，返回路径上总是具有相同数目的 ACK，那么这个时候就是连接理想稳定状态。