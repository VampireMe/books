# 模块配置指令
***

&emsp;&emsp;
一个模块的配置指令是定义在一个静态数组中的。
同样地，看一下从 hello module 中截取的模块配置指令的定义。

    static ngx_command_t ngx_http_hello_commands[] = {
        {
            ngx_string("hello_string"),
            NGX_HTTP_LOC_CONF|NGX_CONF_NOARGS|NGX_CONF_TAKE1,
            ngx_http_hello_string,
            NGX_HTTP_LOC_CONF_OFFSET,
            offsetof(ngx_http_hello_loc_conf_t, hello_string),
            NULL
        },
        {
            ngx_string("hello_counter"),
            NGX_HTTP_LOC_CONF|NGX_CONF_FLAG,
            ngx_http_hello_counter,
            NGX_HTTP_LOC_CONF_OFFSET,
            offsetof(ngx_http_hello_loc_conf_t, hello_counter),
            NULL
        },
        ngx_null_command
    };

&emsp;&emsp;
其实看这个定义就基本能看出来一些信息。
例如定义了两个配置指令，一个叫 hello_string，可以接受一个参数，或者是没有参数。
另外一个命令是 hello_counter，接受一个 NGX_CONF_FLAG 类型的参数。
除此之外似乎看起来有点迷惑。
没有关系，来详细看一下 ngx_command_t，一旦了解这个结构的详细信息，那么相信上述这个定义所表达的所有信息就不言自明了。

&emsp;&emsp;
ngx_command_t 的定义，位于 src/core/ngx_conf_file.h 中。

    struct ngx_command_s {
        ngx_str_t             name;
        ngx_uint_t            type;
        char                 *(*set)(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
        ngx_uint_t            conf;
        ngx_uint_t            offset;
        void                 *post;
    };


+ name:

&emsp;&emsp;
配置指令的名称。

+ type:

&emsp;&emsp;
该配置的类型，其实更准确一点说，是该配置指令属性的集合。
nginx 提供了很多预定义的属性值（一些宏定义），通过逻辑或运算符可组合在一起，形成对这个配置指令的详细的说明。
下面列出可在这里使用的预定义属性值及说明。

&emsp;&emsp;
可以组合多个属性，比如一个指令即可以不填参数，也可以接受1个或者2个参数。
那么就是 NGX_CONF_NOARGS|NGX_CONF_TAKE1|NGX_CONF_TAKE2。
如果写上面三个属性在一起觉得麻烦，那么没有关系，nginx 提供了一些定义，使用起来更简洁。

|定义|说明|
| ------------- | ------------- |
|NGX_CONF_NOARGS|配置指令不接受任何参数。|
|NGX_CONF_TAKE1|配置指令接受 1 个参数。|
|NGX_CONF_TAKE2|配置指令接受 2 个参数。|
|NGX_CONF_TAKE3|配置指令接受 3 个参数。|
|NGX_CONF_TAKE4|配置指令接受 4 个参数。|
|NGX_CONF_TAKE5|配置指令接受 5 个参数。|
|NGX_CONF_TAKE6|配置指令接受 6 个参数。|
|NGX_CONF_TAKE7|配置指令接受 7 个参数。|
|NGX_CONF_TAKE12|配置指令接受 1 个或者 2 个参数。|
|NGX_CONF_TAKE13|配置指令接受 1 个或者 3 个参数。|
|NGX_CONF_TAKE23|配置指令接受 2 个或者 3 个参数。|
|NGX_CONF_TAKE123|配置指令接受 1-3 个参数。|
|NGX_CONF_TAKE1234|配置指令接受 1-4 个参数。|
|NGX_CONF_1MORE|配置指令接受至少一个参数。|
|NGX_CONF_2MORE|配置指令接受至少两个参数。|
|NGX_CONF_MULTI|配置指令可以接受多个参数，即个数不定。|
|NGX_CONF_BLOCK|配置指令可以接受的值是一个配置信息块。也就是一对大括号括起来的内容。里面可以再包括很多的配置指令。比如常见的 server 指令就是这个属性的。|
|NGX_CONF_FLAG|配置指令可以接受的值是”on”或者”off”，最终会被转成 bool 值。|
|NGX_CONF_ANY|配置指令可以接受的任意的参数值。一个或者多个，或者”on”或者”off”，或者是配置块。|

&emsp;&emsp;
最后要说明的是，无论如何 nginx 的配置指令的参数个数不可以超过 NGX_CONF_MAX_ARGS 个。
目前这个值被定义为 8，也就是不能超过 8 个参数值。

&emsp;&emsp;
下面介绍一组说明配置指令可以出现的位置的属性。

|属性|说明|
| ------------- | ------------- |
|NGX_DIRECT_CONF|可以出现在配置文件中最外层。例如已经提供的配置指令 daemon，master_process 等。|
|NGX_MAIN_CONF|http、mail、events、error_log 等。|
|NGX_ANY_CONF|该配置指令可以出现在任意配置级别上。|

&emsp;&emsp;
对于编写的大多数模块而言都是在处理 http 相关的事情，也就是所谓的都是 NGX_HTTP_MODULE，对于这样类型的模块，其配置可能出现的位置也是分为直接出现在 http 里面，以及其他位置。

|配置|说明|
| ------------- | ------------- |
|NGX_HTTP_MAIN_CONF|可以直接出现在 http 配置指令里。|
|NGX_HTTP_SRV_CONF|可以出现在 http 里面的 server 配置指令里。|
|NGX_HTTP_LOC_CONF|可以出现在 http server 块里面的 location 配置指令里。|
|NGX_HTTP_UPS_CONF|可以出现在 http 里面的 upstream 配置指令里。|
|NGX_HTTP_SIF_CONF|可以出现在 http 里面的 server 配置指令里的 if 语句所在的 block 中。|
|NGX_HTTP_LMT_CONF|可以出现在 http 里面的 limit_except 指令的 block 中。|
|NGX_HTTP_LIF_CONF|可以出现在 http server 块里面的 location 配置指令里的 if 语句所在的 block 中。|

+ set:

&emsp;&emsp;
这是一个函数指针，当 nginx 在解析配置时如果遇到这个配置指令，将会把读取到的值传递给这个函数进行分解处理。
因为具体每个配置指令的值如何处理只有定义这个配置指令的人是最清楚的。
来看一下这个函数指针要求的函数原型。

+ char *(*set)(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);

&emsp;&emsp;
先看该函数的返回值，处理成功时，返回NGX_OK，否则返回NGX_CONF_ERROR或者是一个自定义的错误信息的字符串。
再看一下这个函数被调用的时候，传入的三个参数。

+ cf:

&emsp;&emsp;
该参数里面保存从配置文件读取到的原始字符串以及相关的一些信息。
特别注意的是这个参数的 args 字段是一个 ngx_str_t 类型的数组，该数组的首个元素是这个配置指令本身，第二个元素是指令的第一个参数，第三个元素是第二个参数，依次类推。

+ cmd:

&emsp;&emsp;
这个配置指令对应的 ngx_command_t 结构。

+ conf:

&emsp;&emsp;
就是定义的存储这个配置值的结构体，
比如在上面展示的那个 ngx_http_hello_loc_conf_t。
当解析这个 hello_string 变量的时候，传入的 conf 就指向一个 ngx_http_hello_loc_conf_t 类型的变量。
用户在处理的时候可以使用类型转换，转换成自己知道的类型，再进行字段的赋值。
为了更加方便的实现对配置指令参数的读取，nginx 已经默认提供了对一些标准类型的参数进行读取的函数，可以直接赋值给 set 字段使用。
下面来看一下这些已经实现的 set 类型函数。

|函数|说明|
| ------------- | ------------- |
|ngx_conf_set_flag_slot|读取 NGX_CONF_FLAG 类型的参数。|
|ngx_conf_set_str_slot|读取字符串类型的参数。|
|ngx_conf_set_str_array_slot|读取字符串数组类型的参数。|
|ngx_conf_set_keyval_slot|读取键值对类型的参数。|
|ngx_conf_set_num_slot|读取整数类型(有符号整数 ngx_int_t )的参数。|
|ngx_conf_set_size_slot|读取 size_t 类型的参数，也就是无符号数。|
|ngx_conf_set_off_slot|读取 off_t 类型的参数。|
|ngx_conf_set_msec_slot|读取毫秒值类型的参数。|
|ngx_conf_set_sec_slot|读取秒值类型的参数。|
|ngx_conf_set_bufs_slot|读取的参数值是 2 个，一个是 buf 的个数，一个是 buf 的大小。例如：output_buffers 1 128k。|
|ngx_conf_set_enum_slot|读取枚举类型的参数，将其转换成整数 ngx_uint_t 类型。|
|ngx_conf_set_bitmask_slot|读取参数的值，并将这些参数的值以 bit 位的形式存储。例如：HttpDavModule 模块的 dav_methods 指令。|

+ conf:

&emsp;&emsp;
该字段被 NGX_HTTP_MODULE 类型模块所用 (编写的基本上都是 NGX_HTTP_MOUDLE，只有一些 nginx 核心模块是非 NGX_HTTP_MODULE )，该字段指定当前配置项存储的内存位置。
实际上是使用哪个内存池的问题。
因为 http 模块对所有 http 模块所要保存的配置信息，划分了 main, server 和 location 三个地方进行存储，每个地方都有一个内存池用来分配存储这些信息的内存。
这里可能的值为 NGX_HTTP_MAIN_CONF_OFFSET、NGX_HTTP_SRV_CONF_OFFSET 或 NGX_HTTP_LOC_CONF_OFFSET。
当然也可以直接置为 0，就是 NGX_HTTP_MAIN_CONF_OFFSET。

+ offset:

&emsp;&emsp;
指定该配置项值的精确存放位置，一般指定为某一个结构体变量的字段偏移。
因为对于配置信息的存储，一般都是定义个结构体来存储的。
那么比如定义了一个结构体 A，该项配置的值需要存储到该结构体的 b 字段。
那么在这里就可以填写为 offsetof(A, b)。
对于有些配置项，它的值不需要保存或者是需要保存到更为复杂的结构中时，这里可以设置为 0。

+ post:

&emsp;&emsp;
该字段存储一个指针。
可以指向任何一个在读取配置过程中需要的数据，以便于进行配置读取的处理。
大多数时候都不需要，所以简单地设为 0 即可。

&emsp;&emsp;
看到这里应该就比较清楚了。
ngx_http_hello_commands 这个数组每 5 个元素为一组，用来描述一个配置项的所有情况。
那么如果有多个配置项，只要按照需要再增加 5 个对应的元素对新的配置项进行说明。

&emsp;&emsp;
需要注意的是，在 ngx_http_hello_commands 这个数组定义的最后都要加一个 ngx_null_command 作为结尾。
