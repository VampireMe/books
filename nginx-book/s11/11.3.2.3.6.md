# 端口监听表
***

&emsp;&emsp;
对于所有写在 server 配置中的 listen 指令，nginx 开始会建立一张 server 和端口的对照索引表。
虽然这不是本节的要点，但要说明索引表到监听表的转换过程，还是需要描述其结构。
如图 11-3(缺失) 所示，这张索引表是二级索引，第一级索引以 listen 指定的端口为键，第二级索引以 listen 指定的地址为键，索引的对象就是 server 上下文数据结构。
而端口监视表是两张表，其结构如图 11-4(缺失) 所示。
索引表和监听表在结构上非常类似，但是却有一个非常明显的不同。
索引表中第一张表的各表项的端口是唯一的，而监听表的第一张表中的不同表项的端口却可能是相同的。
之所以出现这样的差别是因为 nginx 会为监听表第一张表中的每一项分别建立监听套接字，而在索引表中，如果配置显式定义了需要监听不同 IP 地址的相同端口，它在索引表中会放在同一个端口的二级索引中，而在监听表中必须存放为两个端口相同的不同监听表项。

&emsp;&emsp;
说明了两张表的结构，现在可以介绍转换过程：

&emsp;&emsp;
第一步，在 ngx_http_optimize_servers() 函数中对索引表一级索引中的所有 port 下辖的二级索引分别进行排序。
排序的规则是：

&emsp;&emsp;
(1) 含 wildcard 属性的二级索引最终会尽可能排到尾部。
这些二级索引类似于：

    listen *:80;
    listen 80;

&emsp;&emsp;
(2) 含 bind 属性的二级索引最终会尽可能排到首部。
这些二级索引是由那些设置了 bind、backlog、rcvbuf、sndbuf、accept_filter、deferred、ipv6only 和 so_keepalive 参数的 listen 指令生成的。

&emsp;&emsp;
(3) 其他二级索引，其相对顺序不变，排在含 bind 属性的二级索引之后，而在含 wildcard 属性的二级索引之前。

&emsp;&emsp;
第二步，将索引表转换为监听表，这是在 ngx_http_init_listening() 函数中实现的。
其步骤是：

&emsp;&emsp;
(1) 得到是否有二级索引含有 wildcard 属性，只需要看看排序后的二级索引的最后一项就可以了。

&emsp;&emsp;
(2) 顺次将所有含有 bind 属性的二级索引以一对一的方式生成监听表的表项(第一级和第二级都只有一项)。

&emsp;&emsp;
(3) 如果第一步检测到不含 wildcard 属性，则顺次将后续所有二级索引以一对一的方式生成监听表的表项。

&emsp;&emsp;
(4) 如果第一步检测到含 wildcard 属性，则以含 wildcard 属性的二级索引创建监听表的一级表项，并将二级索引中从第一不含 bind 属性的表项开始的所有表项一同转换成为刚刚创建的监听表一级表项的下级表项。