# 回调函数
***

&emsp;&emsp;
前面剖析了 memcached 模块的骨架，现在开始逐个解决每个回调函数。

&emsp;&emsp;
一、ngx_http_memcached_create_request：很简单的按照设置的内容生成一个 key，接着生成一个“get $key”的请求，放在 r->upstream->request_bufs 里面。

&emsp;&emsp;
二、ngx_http_memcached_reinit_request：无需初始化。

&emsp;&emsp;
三、ngx_http_memcached_abort_request：无需额外操作。

&emsp;&emsp;
四、ngx_http_memcached_finalize_request：无需额外操作。

&emsp;&emsp;
五、ngx_http_memcached_process_header：模块的业务重点函数。memcache 协议的头部信息被定义为第一行文本，可以找到这段代码证明：

    for (p = u->buffer.pos; p < u->buffer.last; p++) {
        if ( * p == LF) {
        goto found;
    }

&emsp;&emsp;
如果在已读入缓冲的数据中没有发现 LF('n') 字符，函数返回 NGX_AGAIN，表示头部未完全读入，需要继续读取数据。
nginx 在收到新的数据以后会再次调用该函数。

&emsp;&emsp;
nginx 处理后端服务器的响应头时只会使用一块缓存，所有数据都在这块缓存中，所以解析头部信息时不需要考虑头部信息跨越多块缓存的情况。
而如果头部过大不能保存在这块缓存中，nginx 会返回错误信息给客户端，并记录 error log，提示缓存不够大。

&emsp;&emsp;
process_header 的重要职责是将后端服务器返回的状态翻译成返回给客户端的状态。
例如在 ngx_http_memcached_process_header 中，有这样几段代码：

    r->headers_out.content_length_n = ngx_atoof(len, p - len - 1);

    u->headers_in.status_n = 200;
    u->state->status = 200;

    u->headers_in.status_n = 404;
    u->state->status = 404;

&emsp;&emsp;
u->state 用于计算 upstream 相关的变量。
比如 u->state->status 将被用于计算变量 “upstream_status” 的值。
u->headers_in 将被作为返回给客户端的响应返回状态码。
而第一行则是设置返回给客户端的响应的长度。

&emsp;&emsp;
在这个函数中不能忘记的一件事情是处理完头部信息以后需要将读指针 pos 后移，否则这段数据也将被复制到返回给客户端的响应的正文中，进而导致正文内容不正确。

    u->buffer.pos = p + 1;

&emsp;&emsp;
process_header 函数完成响应头的正确处理应该返回 NGX_OK。
如果返回 NGX_AGAIN 表示未读取完整数据，需要从后端服务器继续读取数据。
返回 NGX_DECLINED 无意义，其他任何返回值都被认为是出错状态，nginx 将结束 upstream 请求并返回错误信息。

&emsp;&emsp;
六、ngx_http_memcached_filter_init：修正从后端服务器收到的内容长度。
因为在处理 header 时没有加上这部分长度。

&emsp;&emsp;
七、ngx_http_memcached_filter：memcached 模块是少有的带有处理正文的回调函数的模块。
因为 memcached 模块需要过滤正文末尾 CRLF “END” CRLF，所以实现了自己的 filter 回调函数。
处理正文的实际意义是将从后端服务器收到的正文有效内容封装成 ngx_chain_t，并加在 u->out_bufs 末尾。
nginx 并不进行数据拷贝，而是建立 ngx_buf_t 数据结构指向这些数据内存区，然后由 ngx_chain_t 组织这些 buf。
这种实现避免了内存大量搬迁，也是 nginx 高效的奥秘之一。