# lingering_close
***

&emsp;&emsp;
lingering_close 字面意思就是延迟关闭，也就是说当 nginx 要关闭连接时并非立即关闭连接，而是先关闭 tcp 连接的写，再等待一段时间后再关掉连接的读。
为什么要这样呢？我们先来看看这样一个场景。
nginx 在接收客户端的请求时，可能由于客户端或服务端出错了，要立即响应错误信息给客户端，而 nginx 在响应错误信息后，大分部情况下是需要关闭当前连接。
nginx 执行完 write() 系统调用把错误信息发送给客户端，write() 系统调用返回成功并不表示数据已经发送到客户端，有可能还在 tcp 连接的 write buffer 里。
接着如果直接执行 close() 系统调用关闭 tcp 连接，内核会首先检查 tcp 的 read buffer 里有没有客户端发送过来的数据留在内核态没有被用户态进程读取，如果有则发送给客户端 RST 报文来关闭 tcp 连接丢弃 write buffer 里的数据，如果没有则等待 write buffer 里的数据发送完毕，然后再经过正常的 4 次分手报文断开连接。
所以在某些场景下出现 tcp write buffer 里的数据在 write() 系统调用之后到 close() 系统调用执行之前没有发送完毕，且 tcp read buffer 里面还有数据没有读，close() 系统调用会导致客户端收到 RST 报文且不会拿到服务端发送过来的错误信息数据。
那客户端肯定会想，这服务器好霸道，动不动就 reset 我的连接，连个错误信息都没有。

&emsp;&emsp;
在上面这个场景中可以看到，关键点是服务端给客户端发送了 RST 包导致自己发送的数据在客户端忽略掉了。
所以解决问题的重点是让服务端别发 RST 包。
再想想，我们发送RST是因为关掉了连接，关掉连接是因为不想再处理此连接了，也不会有任何数据产生了。
对于全双工的 TCP 连接来说只需要关掉写就行了，读可以继续进行，只需要丢掉读到的任何数据就行了，这样的话，当我们关掉连接后，客户端再发过来的数据，就不会再收到 RST 了。
当然最终还是需要关掉这个读端的，所以会设置一个超时时间，在这个时间过后就关掉读，客户端再发送数据来就不管了，作为服务端会认为，都这么长时间了，发给你的错误信息也应该读到了，再慢就不关我事了，要怪就怪你 RP 不好了。
当然正常的客户端在读取到数据后会关掉连接，此时服务端就会在超时时间内关掉读端。
这些正是 lingering_close 所做的事情。
协议栈提供 SO_LINGER 这个选项，它的一种配置情况就是来处理 lingering_close 的情况的，不过 nginx 是自己实现的 lingering_close。
lingering_close 存在的意义就是来读取剩下的客户端发来的数据，所以 nginx 会有一个读超时时间，通过 lingering_timeout 选项来设置，如果在 lingering_timeout 时间内还没有收到数据，则直接关掉连接。
nginx 还支持设置一个总的读取时间，通过 lingering_time 来设置，这个时间也就是 nginx 在关闭写之后，保留 socket 的时间，客户端需要在这个时间内发送完所有的数据，否则 nginx 在这个时间过后会直接关掉连接。
当然 nginx 是支持配置是否打开 lingering_close 选项的，通过 lingering_close 选项来配置。
那么在实际应用中，是否应该打开 lingering_close 呢？
这个就没有固定的推荐值了，如 Maxim Dounin 所说 lingering_close 的主要作用是保持更好的客户端兼容性，但是却需要消耗更多的额外资源（比如连接会一直占用着）。

&emsp;&emsp;
这节我们介绍了nginx中连接与请求的基本概念，下节我们讲基本的数据结构。